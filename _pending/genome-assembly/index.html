<!doctype html><html lang="it" xmlns="http://www.w3.org/1999/xhtml" class="scrolled-to-top"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="description" content=""><title>DaScH-Lab</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><link href="https://fonts.googleapis.com/css?family=Nunito+Sans:300,400,600,700,800,900" rel="stylesheet"><link href="/assets/css/main-6be7509ce1.css" rel="stylesheet"><link href="/assets/css/cookieconsent-219e4c9c7e.css" rel="stylesheet"><script>const setDarkMode=(e=!1)=>{var t=document.querySelector(":root");e?(t.setAttribute("data-theme","dark"),localStorage.setItem("theme","dark")):(t.setAttribute("data-theme","light"),localStorage.setItem("theme","light"))};var queryScheme=window.matchMedia("(prefers-color-scheme: dark)");const themePreference=localStorage.getItem("theme");var activeTheme=queryScheme.matches;"dark"===themePreference&&(activeTheme=!0),"light"===themePreference&&(activeTheme=!1),setDarkMode(activeTheme)</script></head><body class="has-navbar-fixed-top default"><div id="wrapper"><header class="navbar is-fixed-top"><div class="navbar-brand"><a class="navbar-item" href="/">DaScH-Lab</a><div class="navbar-burger" data-target="main-navbar"><span></span> <span></span> <span></span></div></div><div id="main-navbar" class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a> <a class="navbar-item" href="/docs/">Docs</a></div><div class="navbar-end"><div class="navbar-item"><button class="js__dark-mode-toggle dark-mode-toggle" type="button"><span class="dark-mode-toggle__icon"></span> <span class="dark-mode-toggle__text hidden--visually">dark mode</span></button></div><div class="navbar-item"><a href="https://www.toscanalifesciences.org/" target="_blank"><img src="/assets/images/logotls.png" alt="Bulma: a modern CSS framework based on Flexbox" width="112" height="28"></a></div></div></div></header><section id="content"><div class="container"><header id="docsToggles" class="docs-toggle"><button class="button is-primary is-light bd-fat-button is-small side-button" data-target="offside-menu">Show menu</button> <button class="button is-primary is-light bd-fat-button is-small side-button" data-target="offside-toc">Show sidebar</button></header><div class="docs-wrapper"><aside class="docs-side" id="offside-menu"><div class="menu docs-content"><p class="menu-label"><a href="/docs/">Overview</a></p><ul class="menu-list"><li><a href="/docs/conda/">Conda</a></li><li><a href="/docs/nvidia_mig/">Nvidia Multi-Instance GPU</a></li><li><a href="/docs/pymol/">Pymol</a></li><li><a href="/docs/pytorch_tips_and_tricks/">PyTorch tips and tricks</a></li><li><a href="/docs/screen/">Screen - Terminal multiplexer</a></li></ul><p class="menu-label"><a href="/docs/bioinformatics/">Bioinformatics</a></p></div></aside><div class="docs-toc" id="offside-toc"><div class="docs-content"><strong class="mt-2">On this page</strong><hr><div class="toc"><ul><li><a href="#1-input-reads">1: Input reads</a></li><li><a href="#2-short-read-qc">2: Short-read QC</a></li><li><a href="#3-short-read-assembly-priorities">3: Short-read assembly priorities</a></li><li><a href="#4-skesa-assembly">4: SKESA assembly</a></li><li><a href="#5-spades-assembly">5: SPAdes assembly</a></li><li><a href="#6-unicycler-short-read-assembly">6: Unicycler short-read assembly</a></li><li><a href="#7-long-read-qc">7: Long-read QC</a></li><li><a href="#8-long-read-assembly-priorities">8: Long-read assembly priorities</a></li><li><a href="#9-raven-assembly">9: Raven assembly</a></li><li><a href="#10-flye-assembly">10: Flye assembly</a></li><li><a href="#11-trycycler-assembly">11: Trycycler assembly</a></li><li><a href="#12-long-read-polishing">12: Long-read polishing</a></li><li><a href="#13-medaka">13: Medaka</a></li><li><a href="#14-pacbio-polishing">14: PacBio polishing</a></li><li><a href="#15-long-read-and-short-read-qc">15: Long-read and short-read QC</a></li><li><a href="#16-read-set-depths">16: Read set depths</a></li><li><a href="#17-unicycler-hybrid-assembly">17: Unicycler hybrid assembly</a></li><li><a href="#18-long-read-first-hybrid-assembly">18: Long-read-first hybrid assembly</a></li><li><a href="#19-shallow-reads">19: Shallow reads</a></li><li><a href="#20-short-read-polishing">20: Short-read polishing</a></li><li><a href="#21-small-plasmid-recovery">21: Small-plasmid recovery</a></li><li><a href="#appendix-what-sequencing-should-i-do">Appendix: what sequencing should I do?</a></li></ul></div></div></div><main class="docs-main"><div class="bd-intro"><nav class="navbar" role="navigation" aria-label="page navigation"><div class="navbar-end"><div class="navbar-item"><div class="buttons"><a class="button" href="https://github.com/dasch-lab/dashlab.github.io/tree/master/./src/docs/genome-assembly.md" title="View and edit this file on GitHub" target="_blank" rel="noopener">View on GitHub</a></div></div></div></nav><h1 class="bd-title mb-0" id="content"></h1></div><div class="container"><p>This guidelines is specifically written for assembling bacteria genomes by using multiple tools, but mainly focussing on unicycler.</p><h2 id="1-input-reads" tabindex="-1">1: Input reads</h2><p>What type of reads do you have?</p><ul><li>Short reads (Illumina) only. <a href="#2-short-read-qc">Go to 2</a>.</li><li>Long reads (Oxford Nanopore or PacBio) only. <a href="#7-long-read-qc">Go to 7</a>.</li><li>Both short and long reads (hybrid). <a href="#15-long-read-and-short-read-qc">Go to 15</a>.</li></ul><br><h2 id="2-short-read-qc" tabindex="-1">2: Short-read QC</h2><p>Before starting the actual assembly, I recommend a bit of read QC. My favourite tool at the moment is <a href="https://github.com/OpenGene/fastp">fastp</a>. It's easy to use and lives up to its name (very fast). I usually run it like this:</p><pre><code class="language-bash">fastp --in1 input_1.fastq.gz --in2 input_2.fastq.gz --out1 short_1.fastq.gz --out2 short_2.fastq.gz --unpaired1 short_u.fastq.gz --unpaired2 short_u.fastq.gz
</code></pre><p>It will generate three files: <code>short_1.fastq.gz</code> and <code>short_2.fastq.gz</code> will contain paired reads and <code>short_u.fastq.gz</code> will contain reads which were orphaned by the QC process. Hopefully the <code>u</code> file is very small relative to the <code>1</code> and <code>2</code> files. If not, something might have gone wrong!</p><p><a href="#3-short-read-assembly-priorities">Go to 3.</a></p><br><h2 id="3-short-read-assembly-priorities" tabindex="-1">3: Short-read assembly priorities</h2><p>Since you only have short reads, a complete genome assembly (one contig per replicon) is almost certainly not possible. Your assembly will be fragmented (a.k.a. a draft assembly) because short reads are insufficient to resolve repetitive regions of the genome :cry:</p><p>Now which of the following best applies to you?</p><ul><li>You want very accurate contigs with minimal misassemblies. You're willing to accept shorter contigs (i.e. a more fragmented assembly) if it reduces the risk of misassemblies. <a href="#4-skesa-assembly">Go to 4.</a></li><li>You need a very reproducible assembly. E.g. the same read set should yield exactly the same assembly regardless of the number of threads or available memory. <a href="#4-skesa-assembly">Go to 4.</a></li><li>You will be doing a <em>k</em>-mer-based analysis and nearly all of the genome's <em>k</em>-mers must be represented in the assembly. <a href="#5-spades-assembly">Go to 5.</a></li><li>None of the above. You just want a nice bacterial genome assembly for general purposes. <a href="#6-unicycler-short-read-assembly">Go to 6.</a></li></ul><br><h2 id="4-skesa-assembly" tabindex="-1">4: SKESA assembly</h2><p>For a very accurate and reproducible assembly, I would recommend <a href="https://github.com/ncbi/SKESA">SKESA</a>. Read more about it in <a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-018-1540-z">its paper</a>. It doesn't give the longest contigs, but its misassembly rate is low. You can run it like this:</p><pre><code class="language-bash">skesa --reads short_1.fastq.gz,short_2.fastq.gz --cores 16 --memory 64 &gt; skesa_assembly.fasta
</code></pre><p>I don't think SKESA can simultaneously take paired and unpaired reads, so we didn't use the <code>short_u.fastq.gz</code> here. But that file should only contain a tiny fraction of your total reads, so no big loss.</p><p>One thing to keep in mind is that SKESA can leave out a bit of sequence around tough-to-assemble parts of the genome. This is because it would rather give you no sequence than incorrect sequence. Your assembly can therefore have some gaps and some of the genome's <em>k</em>-mers may not be present in the assembly.</p><p>SKESA assemblies shouldn't require any polishing, so you're now finished! <strong>THE END</strong></p><br><h2 id="5-spades-assembly" tabindex="-1">5: SPAdes assembly</h2><p>If <em>k</em>-mer representation is important, I recommend <a href="https://cab.spbu.ru/software/spades/">SPAdes</a>, because its contigs usually have a bit of overlap with each other. E.g. two adjacent contigs at a point of fragmentation will share some sequence with each other. This means that <em>k</em>-mers at the breakpoint are still in the assembly.</p><p>You can run it like this:</p><pre><code class="language-bash">spades.py -1 short_1.fastq.gz -2 short_2.fastq.gz -s short_u.fastq.gz -o spades_assembly --isolate --threads 16
</code></pre><p>Some things to keep in mind:</p><ul><li>SPAdes produces both a <code>contigs.fasta</code> file and a <code>scaffolds.fasta</code> file. The difference is that the latter may contain N bases, while the former will only have A, C, G and T. For many assemblies (especially if you have good read coverage), those two files may be identical.</li><li>SPAdes produces an assembly graph (<code>assembly_graph.fastg</code>) but this is before any scaffolding takes place, so its sequences will probably be a bit shorter than those in <code>contigs.fasta</code>. While the <code>assembly_graph_with_scaffolds.gfa</code> file sounds like it's been scaffolded, it only contains descriptions of the paths that the scaffolds take in the graph â€“ the sequences have not been merged into scaffolds.</li><li>SPAdes does not filter out low-depth contigs by default, so low-level contamination can creep into your assembly. You may want to experiment with its <code>--cov-cutoff</code> option if that's a problem for you.</li><li>SPAdes disables polishing when you use the <code>--isolate</code> option. If you want to do polishing, you can use the <code>--careful</code> option instead.</li><li>I don't have much experience with <a href="https://github.com/tseemann/shovill">Shovill</a>, but that's a SPAdes-based assembly pipeline which takes care of a lot of things for you: subsampling reads to a lower depth, filtering out low-depth contigs, renaming contigs, etc. If you want to do a SPAdes assembly but not worry about the details, give it a try!</li></ul><p>You're now finished! <strong>THE END</strong></p><br><h2 id="6-unicycler-short-read-assembly" tabindex="-1">6: Unicycler short-read assembly</h2><p>For most short-read bacterial genome assemblies, I'd recommend <a href="https://github.com/rrwick/Unicycler">Unicycler</a>. (Disclaimer: it's my own tool so I may be biased :smile:)</p><p>For short-read-only assemblies, Unicycler just runs SPAdes and then adds few extra touches:</p><ul><li>Filters out low-depth contigs by default to remove low-level contamination.</li><li>Applies SPAdes scaffolding to the graph so you can get your final assembly in graph form.</li><li>Normalises contig depth to the chromosomal level.</li><li>Trims overlaps from the graph so contigs don't overlap (could be a bad thing if you're doing <em>k</em>-mer-based analysis, <a href="#5-spades-assembly">see step 5</a>).</li></ul><p>I usually run it like this:</p><pre><code class="language-bash">unicycler -1 short_1.fastq.gz -2 short_2.fastq.gz -s short_u.fastq.gz -o unicycler_assembly --threads 16 --no_correct --no_pilon
</code></pre><p>Unicycler will produce its final assembly in FASTA format (<code>assembly.fasta</code>) and as a graph (<code>assembly.gfa</code>). They contain identical sequences, except the <code>assembly.fasta</code> file has very short (&lt;100 bp by default) contigs excluded.</p><p>I have found that read error correction isn't needed, especially if you do some read QC beforehand, hence my use of the <code>--no_correct</code> option. Also, I'm not convinced that <a href="https://github.com/broadinstitute/pilon">Pilon-polishing</a> for a short-read-only assembly it worth it, so I tend to use <code>--no_pilon</code> which saves a lot of time. Remove this option if you want to turn polishing back on.</p><p>One mild annoyance to keep in mind: SPAdes changed its output files in v3.13.1 which made it incompatible with Unicycler, so you'll have to downgrade SPAdes to <a href="http://cab.spbu.ru/files/release3.13.0">v3.13.0</a>.</p><p>You're now finished! <strong>THE END</strong></p><br><h2 id="7-long-read-qc" tabindex="-1">7: Long-read QC</h2><p>I'm assuming here that you already have basecalled and demultiplexed long reads in FASTQ format. If not, you can check out the <a href="#appendix-oxford-nanopore-basecalling">Oxford Nanopore basecalling</a> appendix.</p><p>Before continuing with long-read assembly, I often like to do some light QC on the reads with <a href="https://github.com/rrwick/Filtlong">Filtlong</a>:</p><pre><code class="language-bash">filtlong --min_length 1000 --keep_percent 95 input.fastq.gz | gzip &gt; long.fastq.gz
</code></pre><p>This will remove any reads shorter than 1 kbp and also exclude the worst 5% of reads. The goal is just to get the really bad reads out of your set.</p><p>I usually keep QC light for two reasons, the first being small plasmids. Filtlong considers shorter reads 'bad' and longer reads 'good' so more aggressive filtering will leave you with few reads on the short end of the spectrum. For most of the genome this is probably a good thing, but it can be disastrous for small plasmids. For example, if you have a big read set that you've aggressively filtered with Filtlong, you might be left with no reads smaller than 10 kbp. If that genome has a small plasmid 4 kbp in size, it will now be gone from the read set!</p><p>The second reason I keep QC light is that deep long-read sets can benefit assembly. This is especially true if you end up using Trycycler, where deeper sets allow for more independent input assemblies (see [[Generating assemblies]]). Other assemblers handle deep read sets just fine too, so when in doubt, aim for deep.</p><p>That being said, if you have an <em>extremely</em> deep long-read set (e.g. 500Ã—) then more aggressive QC is warranted. Just be careful about not losing all your shorter reads if small plasmids are important to you. Filtlong has some options which might help, like <code>--mean_q_weight</code> which can make it prioritise quality over length and <code>--min_mean_q</code> which can set a hard threshold for read quality.</p><p><a href="#8-long-read-assembly-priorities">Go to 8.</a></p><br><h2 id="8-long-read-assembly-priorities" tabindex="-1">8: Long-read assembly priorities</h2><p>With long reads, you will probably be able to get a complete assembly: one contig per replicon in the genome. This relies on you having reads which are longer than the longest repeat in the genome, but for most bacterial genomes, this isn't hard. E.g. if your genome's longest repeat is 6 kbp and your reads have an N50 length of 10 kbp, assembly should proceed well. But keep in mind that some bacterial genomes do have very long repeats (e.g. 100 kbp) and complete assembly in such cases will require ultra-long reads.</p><p>Another thing to keep in mind: long reads have higher error rates than short reads, and since these errors aren't completely random, some can persist into the final assembly. So don't expect a 100% accurate assembly with long reads alone, though in many cases you can get pretty close. This applies to both Oxford Nanopore and PacBio reads, though PacBio can probably provide higher assembly accuracy.</p><p>With that out of the way, which of the following best applies to you?</p><ul><li>Computational performance is important. You have a lot of assemblies to do and want them done fast! <a href="#9-raven-assembly">Go to 9.</a></li><li>Assembly accuracy is important. You're willing to accept a slower assembly if it's more accurate. <a href="#10-flye-assembly">Go to 10.</a></li><li>You want the most accurate possible assembly and are willing to spend time and effort to get it. <a href="#11-trycycler-assembly">Go to 11.</a></li></ul><br><h2 id="9-raven-assembly" tabindex="-1">9: Raven assembly</h2><p><a href="https://github.com/lbcb-sci/raven">Raven</a> is not as fast as Shasta, but it's still pretty fast, and it usually produces better assemblies. <a href="https://f1000research.com/articles/8-2138">In my tests</a> it was also very reliable and robust. You can run it like this:</p><pre><code class="language-bash">raven --threads 16 long.fastq.gz &gt; raven_assembly.fasta
</code></pre><p>Since you chose computational performance over accuracy, I'm going to assume that you're not interested in post-assembly polishing steps. So you're now finished! <strong>THE END</strong></p><br><h2 id="10-flye-assembly" tabindex="-1">10: Flye assembly</h2><p>While there are many different metrics with which one can evaluate <a href="https://f1000research.com/articles/8-2138">long-read assemblers</a>, <a href="https://github.com/fenderglass/Flye">Flye</a> is an overall strong performer. Its main downside is that you'll need a bit more computational resources than you would for other assemblers. 32 GB of RAM and 1 hour should be sufficient for most read sets.</p><p>You can run Flye like this (or with <code>--pacbio-raw</code> as appropriate):</p><pre><code class="language-bash">flye -o flye_assembly --plasmids --threads 16 --nano-raw long.fastq.gz
</code></pre><p>Flye's <code>--plasmids</code> option enables a nice feature which tries to recover small plasmids in the genome. However, it has a nasty habit of sometimes doubling small plasmids in a single contig. E.g. if your genome has a 4 kbp plasmid, Flye might create an 8 kbp contig with two whole copies of the plasmid sequence. Something to keep an eye out for!</p><p>When your Flye assembly is done:</p><ul><li>If sequence accuracy is not particularly important to your analyses, then a Flye assembly is probably enough and you're finished! <strong>THE END</strong></li><li>But polishing can significantly improve accuracy, so if that sounds appealing to you, <a href="#12-long-read-polishing">go to 12</a>.</li></ul><br><h2 id="11-trycycler-assembly" tabindex="-1">11: Trycycler assembly</h2><p>Running <a href="https://github.com/rrwick/Trycycler">Trycycler</a> is more involved than other approaches, but it can yield the best assemblies. (Disclaimer: it's my own tool so I may be biased :smile:) It also allows you to clearly see whether or not your read set is sufficient for a reliable assembly (via the [[clustering step|Clustering-contigs]]). I won't say more about it here â€“ you are on the Trycycler wiki after all, so read more about it on the other pages!</p><p>When your Trycycler assembly is done:</p><ul><li>If sequence accuracy is not particularly important to your analyses, then a Trycycler assembly is probably enough and you're finished! <strong>THE END</strong></li><li>But polishing can significantly improve accuracy, so if that sounds appealing to you, <a href="#12-long-read-polishing">go to 12</a>.</li></ul><br><h2 id="12-long-read-polishing" tabindex="-1">12: Long-read polishing</h2><p>Long-read polishing can significantly improve sequence accuracy, and since long reads can span most repeats, long-read polishing can make repeats just as accurate as non-repetitive sequences. If you have a hybrid read set (both short and long reads), I recommend you do long-read polishing first and short-read polishing second.</p><p><a href="https://github.com/isovic/racon">Racon</a> is a platform-agnostic tool which can work with both Oxford Nanopore and PacBio reads. However, I've found that it's not usually necessary â€“ most long-read assemblers produce sufficiently accurate sequence all by themselves. And some (<a href="https://github.com/lbcb-sci/raven">Raven</a> and <a href="https://github.com/rrwick/Minipolish">Miniasm/Minipolish</a>) have Racon integrated into their pipeline.</p><p>I therefore think it's appropriate to jump right to the platform-specific polishers:</p><ul><li>If you have Oxford Nanopore reads, <a href="#13-medaka">go to 13.</a></li><li>If you have PacBio reads, <a href="#14-pacbio-polishing">go to 14.</a></li></ul><br><h2 id="13-medaka" tabindex="-1">13: Medaka</h2><p><a href="https://github.com/nanoporetech/medaka">Medaka</a> is Oxford Nanopore's polishing tool, and it seems to work very well for cleaning up a Nanopore-only assembly. Conveniently, it operates on FASTQ reads and so does not require raw data. It's also pretty fast!</p><p>If you did a Trycycler assembly, you can do Medaka polishing on a per-replicon basis (because Trycycler sorts reads by replicon). Read more about that on the [[Polishing after Trycycler]] page. If you didn't run Trycycler, you can run it on your entire assembly like this:</p><pre><code class="language-bash">medaka_consensus -i long.fastq.gz -d input_assembly.fasta -o medaka -m r941_min_high_g360
</code></pre><p>Some things to keep in mind:</p><ul><li>Medaka needs to know which Guppy version and model you used to basecall your reads. So change the <code>-m</code> option as appropriate for your data.</li><li>The Medaka docs say that it was trained on Racon-polished sequences and you should therefore run it on Racon-polished sequences. However, I've found that this doesn't really matter, e.g. Medaka does a great job on Flye assemblies where Racon wasn't used. Racon can also annoyingly truncate sequences that it polishes, so I don't recommend running it before Medaka.</li></ul><p>After Medaka is done:</p><ul><li>If you only have long reads for your genome, then you're finished! <strong>THE END</strong></li><li>If you also have short reads (i.e. you're doing a hybrid assembly), then <a href="#20-short-read-polishing">go to 20</a>.</li></ul><br><h2 id="14-pacbio-polishing" tabindex="-1">14: PacBio polishing</h2><p>If you have older CLR PacBio reads (single-pass reads with lower accuracy), then you should use Arrow to polish your assembly. Arrow is PacBio's polishing algorithm, and you can run it via the <a href="https://github.com/PacificBiosciences/gcpp">GCpp tool</a>. I must confess that I have less experience with PacBio than Oxford Nanopore, but when I last used Arrow it gave very good sequence accuracy. However, it does require the raw read data (not FASTQ reads) which makes it more cumbersome to run.</p><p>If you have newer <a href="https://www.pacb.com/smrt-science/smrt-sequencing/hifi-reads-for-highly-accurate-long-read-sequencing">HiFi PacBio reads</a>, then polishing at this step is probably not necessary. That's because your PacBio platform has already run an Arrow-like algorithm on the individual reads (which are themselves consensus sequences). So consider your assembly already polished!</p><ul><li>If you only have long reads for your genome, then you're finished! <strong>THE END</strong></li><li>If you also have short reads (i.e. you're doing a hybrid assembly), then <a href="#20-short-read-polishing">go to 20</a>.</li></ul><br><h2 id="15-long-read-and-short-read-qc" tabindex="-1">15: Long-read and short-read QC</h2><p>Congratulations on having a hybrid read set â€“ it bodes well for getting a genome assembly that is both accurate and complete! Before continuing, you should do some light QC on your reads. I won't repeat myself, so look back to <a href="#2-short-read-qc">step 2 for short-read QC</a> and <a href="#7-long-read-qc">step 7 for long-read QC</a>.</p><p>One other thing to keep in mind: your short and long reads should be consistent with each other â€“ i.e. they should be sampling from the exact same genome. See the <a href="#appendix-hybrid-read-set-mismatch">hybrid read set mismatch appendix</a> for more about this.</p><p><a href="#16-read-set-depths">Go to 16.</a></p><br><h2 id="16-read-set-depths" tabindex="-1">16: Read set depths</h2><p>The best hybrid assembly approach will depend on the depths of your read sets. To calculate these values, you'll need to know the approximate genome size: depth = (bases in reads) / (bases in genome). For example, if your genome is 4 Mbp and you have 600 Mbp of reads, then your read depth is 150Ã—.</p><p>Here are some arbitrary depth ranges we can use:</p><ul><li>shallow: 0â€“50Ã—</li><li>medium: 50â€“100Ã—</li><li>deep: &gt;100Ã—</li></ul><p>Which of the following best applies to you?</p><ul><li>Your short-read set is deep but your long-read set is shallow. <a href="#17-unicycler-hybrid-assembly">Go to 17.</a></li><li>Your long-read set is deep. <a href="#18-long-read-first-hybrid-assembly">Go to 18.</a></li><li>Neither your short-read nor long-read sets are deep. <a href="#19-shallow-reads">Go to 19.</a></li></ul><br><h2 id="17-unicycler-hybrid-assembly" tabindex="-1">17: Unicycler hybrid assembly</h2><p><a href="https://github.com/rrwick/Unicycler">Unicycler</a> is getting a bit long in the tooth, but its hybrid assembly approach is still appropriate for cases where long reads are limited ([[read more on Trycycler's FAQ|FAQ-and-miscellaneous-tips#should-i-use-unicycler-or-trycycler-to-assemble-my-bacterial-genome]]).</p><p>Unicycler works by first generating a short-read assembly graph and then using long reads to scaffold the graph to completion. It performs best when the short reads are deep and have even coverage, as this makes for a clean graph on which it can work. Not many long reads are then required â€“ as little as 10Ã— can sometimes be enough.</p><p>Run a Unicycler hybrid assembly like this:</p><pre><code class="language-bash">unicycler -1 short_1.fastq.gz -2 short_2.fastq.gz -s short_u.fastq.gz -l long.fastq.gz -o unicycler_assembly --threads 16 --no_correct
</code></pre><p>After making a short-read assembly graph, Unicycler tries to assign a multiplicity value to each contig: a multiplicity of 1 means single-copy (the contig occurs once in the genome) while a multiplicity of 2 or more means repeat (the contig occurs more than once in the genome). If Unicycler makes a mistake in this step, it can cause problems with the scaffolding which lead to an incomplete assembly. This is one of the most common reasons that Unicycler fails to completely assemble a nice hybrid read set. You therefore might want to check the double-check the multiplicity and fix any errors you see. Read more about this on <a href="https://github.com/rrwick/Unicycler/wiki/Multiplicity-mistake">Unicycler's wiki</a>.</p><p>Since Unicycler runs Pilon as part of its pipeline, it should not be necessary to polish its final assembly. When Unicycler is done, then you're finished! <strong>THE END</strong></p><br><h2 id="18-long-read-first-hybrid-assembly" tabindex="-1">18: Long-read-first hybrid assembly</h2><p>Deep long reads allow for a long-read-first approach to hybrid assembly, which is my preference. You should be able to get a very nice genome sequence! You'll be doing a long-read-only assembly followed by short-read polishing.</p><p><a href="#8-long-read-assembly-priorities">Go to 8.</a></p><br><h2 id="19-shallow-reads" tabindex="-1">19: Shallow reads</h2><p>If both your short-read and long-read sets are shallow, then you're in a tough spot! Getting a nice assembly might not be easy. I would recommend trying both Unicycler's short-read-first approach (<a href="#17-unicycler-assembly">step 17</a>) and a long-read-first approach (<a href="19-long-read-first-hybrid-assembly">step 19</a>). Then compare the two resulting assemblies to see which looks better. Good luck!</p><br><h2 id="20-short-read-polishing" tabindex="-1">20: Short-read polishing</h2><p>Even after long-read polishing, there are still probably some errors in your bacterial genome, mainly homopolymer-length errors. Since Illumina reads don't suffer from the same types of errors, you can use short-read polishing to clean these up and get a very accurate assembly.</p><p><a href="https://github.com/rrwick/Polypolish">Polypolish</a> is a tool I've written for this purpose, and I also quite like <a href="https://github.com/alekseyzimin/masurca#polca">POLCA</a>. I've written more about short-read polishing in Trycycler's wiki, so follow the instructions there: [[Polishing after Trycycler|Polishing-after-Trycycler#short-read-polishing]].</p><p>Can short-read polishing make your genome perfect, i.e. with absolutely no errors? If your read sets were good and there were no complications along the way, then I think this is definitely possible but not guaranteed. The most challenging errors to fix are those in repeats, and they can be minimised by getting your assembly as good as possible before short-read polishing. This is why long-read polishing is important (e.g. Trycyler+Medaka+Polypolish+POLCA should do better than Trycycler+Polypolish+POLCA).</p><p>After short-read polishing:</p><ul><li>If you don't care about small plasmids (or if you happen to know that your genome doesn't contain small plasmids), then you're finished! <strong>THE END</strong></li><li>If small plasmids are important to you, <a href="#21-small-plasmid-recovery">go to 21.</a></li></ul><br><h2 id="21-small-plasmid-recovery" tabindex="-1">21: Small-plasmid recovery</h2><p>Small plasmids can sometimes be underrepresented in long-read sets, especially if your read lengths are long and you used a ligation-based sample prep (read more about this in the <a href="#long-read-sequencing">appendix below</a>). This means that your assembled genome could be missing one or more small plasmids if you've done a long-read-first hybrid assembly.</p><p>To solve this problem, I'd recommend you do a Unicycler hybrid assembly (see <a href="#17-unicycler-hybrid-assembly">step 17</a>) of your genome. See if any small plasmids appear in the Unicycler assembly that aren't in your long-read-first assembly. If so, manually copy them over and then you're finished! <strong>THE END</strong></p><br><br><h2 id="appendix-what-sequencing-should-i-do" tabindex="-1">Appendix: what sequencing should I do?</h2><p>If you're reading this page before you've done any sequencing, then I applaud your foresight! The best sequencing approach will depend on your downstream analyses, and limited funds can lead to tough trade-offs (e.g. deep sequencing of fewer isolates or shallow sequencing of more isolates). This is a big topic, so I'll only be able to scratch the surface.</p><h4 id="short-read-sequencing" tabindex="-1">Short-read sequencing</h4><p>Short-read sequencing (mostly synonymous with Illumina sequencing) has some clear advantages over long-read sequencing. It's often cheaper, especially if you have a large number of isolates to multiplex. It's also been in widespread use for longer, so there are a lot of mature tools and pipelines.</p><p>A lot can be learned from short reads alone. Is a gene present in the genome? What alleles are present? What species is the genome? What is the phylogeny of your samples? If you only need to answer questions like these, you may not need long reads.</p><p>The main downside of short-read sequencing regards assembly completeness. Since short reads cannot span many repeats in the genome, they do not provide enough information to get a complete assembly (one contig per replicon) in all but the very simplest bacterial genomes. A short-read assembly will therefore consist of fragmented contigs, some big and some small, making it difficult to see the large-scale genomic structure. How many plasmids are in the genome? Is a gene of interest on the chromosome or on a plasmid? Is a gene of interest in a mobilizable cluster? How are insertion sequences distributed in the genome? Is a phage sequence separate and circular or integrated into the chromosome? These kinds of questions can require long reads to answer.</p><p>Regarding sequencing depth, more is better! However, I don't see much benefit in exceeding 200Ã— â€“ beyond that is probably a waste of money. For financial reasons, much shallower sequencing is often called for, e.g. when it enables sequencing of more isolates (100 isolates at 20Ã— depth could cost the same as 20 isolates at 100Ã— depth). Shallow sequencing is fine for many downstream applications, but it will result in more fragmented assemblies. I wouldn't go below 20Ã— depth unless you're sure that your analysis will be okay with it (and don't expect good assemblies).</p><p>For Illumina sequencing, there are a couple ways of preparing the library: either the <a href="https://www.illumina.com/products/by-type/sequencing-kits/library-prep-kits/truseq-dna-pcr-free.html">TruSeq prep</a> which involves fragmenting the DNA mechanically or the <a href="https://www.illumina.com/products/by-type/sequencing-kits/library-prep-kits/nextera-dna-flex.html">Nextera prep</a> (now confusingly called 'Illumina DNA Prep') which uses an enzyme to fragment the DNA. If you have the option, I'd recommend TruSeq as it results in more even depth of coverage. Nextera, in contrast, results in more variable depth because the enzyme prefers to cut some sequences more than others. If Nextera is your only option, that's okay, but I would encourage you to aim for deeper sequencing to compensate for the less-even coverage.</p><h4 id="long-read-sequencing" tabindex="-1">Long-read sequencing</h4><p>Oxford Nanopore and PacBio both make long-read sequencing platforms. Their reads can be tens of kilobases in length (or more), which means that in most cases reads can span all repeats in a bacterial genome, enabling a complete assembly (one contig per replicon). You can then answer scientific questions about large-scale structure such as those listed above.</p><p>One downside of long-read sequencing is cost. While it has gotten cheaper over time, long-read sequencing is still more expensive than short-read sequencing in many cases. The major exception to this would be the initial cost of the sequencer itself: the Oxford Nanopore MinION is far cheaper than any Illumina sequencer.</p><p>Another downside is the error rate of the final assembly. Long reads have more errors than short reads, and while most of these errors can be fixed in the assembly/polishing steps, some can remain. A common case is homopolymer runs: a sequence like <code>TTTTTTTTTTT</code> is challenging for long-read sequencers/assemblers to get right (e.g. they might report 10 Ts instead of 11). This problem isn't as bad as it used to be, but it still exists.</p><p>I'm not very qualified to discuss Oxford Nanopore vs PacBio, as most of my experience is with the former, so I'll keep this brief. Oxford Nanopore is much cheaper if you need to buy the sequencer itself. Assuming you already have a sequencer, Oxford Nanopore is still probably cheaper on a per-bacterial-genome basis, though PacBio's newer platforms are not too far behind here. Oxford Nanopore can give better read lengths than PacBio (especially if you optimise for ultra-long reads) which will be handy if you have a very complex genome with long repeats. For a typical not-too-complex bacterial genome, both Oxford Nanopore and PacBio reads will be long enough. The Oxford Nanopore MinION is very small and portable, which is a big advantage for field work and mobile labs. Modern PacBio platforms can make HiFi reads which have much better sequence accuracy than Oxford Nanopore reads. PacBio is probably also better for consensus accuracy: the assembly will have fewer residual errors. For this reason, if you're after an extremely high-quality assembly, PacBio sequencing is a good choice. However, I think that hybrid sequencing (see <a href="#hybrid-sequencing">below</a>) can yield the best genomes of all.</p><p>Regarding long-read sequencing depth, I'll say roughly the same thing as for short reads: more is better up to ~200Ã—, and less than 20Ã— is a bad idea. If you want very high quality assemblies, aim for the high end of that spectrum. If you're doing PacBio HiFi sequencing, then you can probably get away with the lower end of that spectrum. A decent MinION run should yield about 10 Gbp of total sequence, and a very good MinION run will yield about 20 Gbp. This means that multiplexing 12 or 24 genomes on a single run is often a good amount. However, getting an even distribution of barcodes can be difficult (e.g. you might get 2 Gbp from one barcode and only 200 Mbp from another) so be prepared for the possibility that you might need to re-sequence some of the genomes on your run.</p><p>Both Oxford Nanopore and PacBio are single-molecule sequencers: each read comes from one molecule of DNA. This means that your read lengths are largely dependent on the length of your DNA molecules. So if your DNA gets sheared during extraction/prep (bead-beating, lots of pipetting, freeze/thaw cycles, etc.) your reads will be shorter. Conversely, a gentle extraction/prep can yield very long reads. Some researchers have <a href="https://www.nature.com/articles/nbt.4060">designed protocols for ultra-long reads</a>, but this is probably not necessary for most bacterial genomes where repeats aren't as bad as in eukaryotes. However, longer is generally better, so I would recommend you aim for the longest reads you reasonably can. The one caveat to this regards small plasmids.</p><p>Small plasmids can be a problem with long-read sequencing. Consider a genome with a 3 kbp plasmid where DNA was extracted for Nanopore sequencing with a typical length of 20 kbp. This means that the 3 kbp plasmid is likely to be completely intact and still circular! A <a href="https://store.nanoporetech.com/sample-prep/ligation-sequencing-kit.html">ligation-based prep</a> would then fail to sequence this plasmid because there are no blunt DNA ends on which adapters can be ligated. For this reason, small plasmids can be very underrepresented in long-read sets. Shearing your DNA might solve the problem, but it would result in shorter reads that could compromise the rest of your assembly. A better solution is to use a <a href="https://store.nanoporetech.com/catalog/product/view/id/226/s/rapid-barcoding-kit/">rapid prep</a> instead, as that doesn't rely on blunt ends. Or you could do hybrid sequencing (see below) and rely on Illumina reads to capture the small plasmid. <a href="https://www.biorxiv.org/content/10.1101/2021.02.21.432182v1">We recently wrote a paper that explores this topic in more detail</a>, so take a look if you're interested.</p><h4 id="hybrid-sequencing" tabindex="-1">Hybrid sequencing</h4><p>Hybrid sequencing refers to getting both short and long reads from the sample isolate. This can give you the best of both worlds! Pretty much all downstream analyses will be available to you. Having a nice hybrid read set will also allow you to make a very high-quality assembly, perfect for creating reference genomes. It will also solve the small plasmid problem described above. Specifically, I would recommend you produce a deep (&gt;100Ã—) long-read set and a medium (~50Ã—) short-read set. This will allow you to perform a long-read-first hybrid assembly (e.g. Trycycler+Medaka+Polypolish+POLCA), which in my experience is the most accurate.</p><p>I strongly encourage you to grow and extract the DNA only once for each isolate, using the same DNA for both short-read and long-read sequencing. This way you can be certain that the two read sets are in exact agreement and avoid the problems described in the <a href="#appendix-hybrid-read-set-mismatch">hybrid read set mismatch</a> appendix.</p></div></main></div><script type="text/javascript">window.addEventListener("load",function(){$(".side-button").click(function(){var t=$(this).data("target");$(this).toggleClass("is-active"),$("#"+t).toggleClass("is-active")})})</script></div></section></div><footer class="footer"><div class="content has-text-centered"><small>The following pages contain links to other features, websites and or content belonging to or originating from third parties: by accessing you agree to the terms and conditions of use set forth therein. <strong>DaScH-Lab</strong> and the TLS disclaims any responsibility and recommend that you carefully read the terms and conditions of use set forth.</small></div></footer><script defer="defer" src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script defer="defer" src="/assets/js/cookieconsent-3a7dc6733a.js"></script><script type="text/javascript">window.addEventListener("load",function(){$(".navbar-burger").click(function(){var e=$(this).data("target");$(this).toggleClass("is-active"),$("#"+e).toggleClass("is-active")});const e=()=>{var e=document.querySelector(":root").getAttribute("data-theme");setDarkMode("light"===e)};var t,o;[t=!1]=[activeTheme],o=window.matchMedia("(prefers-color-scheme: dark)"),setDarkMode(t),o.addListener(e=>setDarkMode(e.matches)),document.querySelector(".js__dark-mode-toggle").addEventListener("click",e),initCookieConsent().run({current_lang:"en",autoclear_cookies:!0,page_scripts:!0,cookie_name:"daschlabcookie",languages:{en:{consent_modal:{title:"We use cookies!",description:'Hi, this website uses essential cookies to ensure its proper operation and tracking cookies to understand how you interact with it. The latter will be set only after consent. <button type="button" data-cc="c-settings" class="cc-link">Let me choose</button>',primary_btn:{text:"Accept all",role:"accept_all"},secondary_btn:{text:"Reject all",role:"accept_necessary"}},settings_modal:{title:"Cookie preferences",save_settings_btn:"Save settings",accept_all_btn:"Accept all",reject_all_btn:"Reject all",close_btn_label:"Close",cookie_table_headers:[{col1:"Name"},{col2:"Domain"},{col3:"Expiration"},{col4:"Description"}],blocks:[{title:"Cookie usage ðŸ“¢",description:'I use cookies to ensure the basic functionalities of the website and to enhance your online experience. You can choose for each category to opt-in/out whenever you want. For more details relative to cookies and other sensitive data, please read the full <a href="/en/privacy/" class="cc-link">privacy policy</a>.'},{title:"Strictly necessary cookies",description:"These cookies are essential for the proper functioning of my website. Without these cookies, the website would not work properly",toggle:{value:"necessary",enabled:!0,readonly:!0}},{title:"Performance and Analytics cookies",description:"These cookies allow the website to remember the choices you have made in the past",toggle:{value:"analytics",enabled:!1,readonly:!1},cookie_table:[{col1:"^_ga",col2:"google.com",col3:"2 years",col4:"description ...",is_regex:!0},{col1:"_gid",col2:"google.com",col3:"1 day",col4:"description ..."}]},{title:"Advertisement and Targeting cookies",description:"These cookies collect information about how you use the website, which pages you visited and which links you clicked on. All of the data is anonymized and cannot be used to identify you",toggle:{value:"targeting",enabled:!1,readonly:!1}},{title:"More information",description:'For any queries in relation to our policy on cookies and your choices, please <a class="cc-link" href="/contacts/">contact us</a>.'}]}}}})})</script></body></html>